# Archived functions - moved here as they had zero usage in shell history
# To restore, copy the function back to functions.symlink

python-http(){
  chrome http://localhost:8000
  python3 -m http.server 8000
}

xcat(){
	cat $1 | pbcopy
}

xpwd(){
  pwd | pbcopy
}

xfile(){
  readlink -f $1 | pbcopy
}

pgres(){
  sudo su - postgres
}

set-executable(){
  sudo chmod uog+x $1
}

git-fix-author(){
  # Customize these values in your .local-functions file
  WRONG_EMAIL=${GIT_FIX_WRONG_EMAIL:-"wrong@example.com"}
  NEW_NAME=${GIT_FIX_NEW_NAME:-"Your Name"}
  NEW_EMAIL=${GIT_FIX_NEW_EMAIL:-"correct@example.com"}

  if [ "$GIT_COMMITTER_EMAIL" = "$WRONG_EMAIL" ]
  then
      export GIT_COMMITTER_NAME="$NEW_NAME"
      export GIT_COMMITTER_EMAIL="$NEW_EMAIL"
  fi
  if [ "$GIT_AUTHOR_EMAIL" = "$WRONG_EMAIL" ]
  then
      export GIT_AUTHOR_NAME="$NEW_NAME"
      export GIT_AUTHOR_EMAIL="$NEW_EMAIL"
  fi
}

git-push-existing-repo()
{
  git remote add origin $1
  git branch -M main
  git push -u origin main
}

python-lint()
{
  uv run black --line-length 120 -S .
  uv run flakeheaven lint
  uv run isort -w 120 --profile=black .
  uv run mypy .
}

dcu()
{
  if [ "$1" = "--rebuild" ]
  then
    docker compose up --build --force-recreate --no-deps
  elif [ ! -z "$1" ]
  then
    echo "$1 not a correct argument; pass --rebuild or nothing"
  else
    docker compose up
  fi
}

pvd()
{
  pyenv virtualenv-delete -f $1
}

bats() {
    BATS_RUN_SKIPPED=true command bats *.bats
}

git-pull-recursive() {
  find . -type d -name ".git" -exec sh -c '
      dir=$(dirname "{}")
      echo "Processing directory: $dir"
      branch=$(git -C "$dir" symbolic-ref --short HEAD)
      if [ "$branch" != "main" ]; then
          git -C "$dir" checkout main || { echo "Failed to checkout main in $dir"; exit 1; }
      fi
      git -C "$dir" pull
  ' \;
}

git-fetch-recursive() {
  find . -type d -name ".git" -exec sh -c '
      dir=$(dirname "{}")
      echo "Processing directory: $dir"
      branch=$(git -C "$dir" symbolic-ref --short HEAD)
      if [ "$branch" != "main" ]; then
          git -C "$dir" checkout main || { echo "Failed to checkout main in $dir"; exit 1; }
      fi
      git -C "$dir" fetch
  ' \;
}

git-switch-recursive() {
    new_branch="$1"

    echo "New branch name $new_branch"
    if [ -z "$new_branch" ]; then
        echo "Error: No branch name provided."
        return 1
    fi

    find . -type d -name ".git" -exec sh -c '
        dir=$(dirname "{}")
        echo "Processing directory: $dir"

        if git -C "$dir" rev-parse --verify --quiet "$1"; then
            echo "Branch $1 already exists in $dir"
            git -C "$dir" checkout "$1" || { echo "Failed to switch to existing branch in $dir"; exit 1; }
        else
            git -C "$dir" checkout -b "$1" || { echo "Failed to create new branch in $dir"; exit 1; }
        fi
    ' _ "$new_branch" \;
}

git-branch-latest() {
  git for-each-ref --sort=-committerdate --format='%(committerdate:short) %(authorname) %(refname:short) %(subject)' refs/heads/
}

git-commits-not-on-main() {
  # Ensure the script is run inside a Git repository
  if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
      echo "This script must be run inside a Git repository."
      return 1
  fi

  # Detect the default branch (either 'main' or 'master')
  if git show-ref --quiet refs/heads/main; then
      default_branch="main"
  elif git show-ref --quiet refs/heads/master; then
      default_branch="master"
  else
      echo "Neither 'main' nor 'master' branch found."
      return 1
  fi

  echo "Branch | Commits not on '$default_branch'"
  echo "------------------------------"

  # Get the list of all local branches and handle each line individually
  git for-each-ref --format='%(refname:short)' refs/heads/ | while read -r branch; do
      if [ "$branch" != "$default_branch" ]; then
          # Count commits on the branch that are not in the default branch
          commit_count=$(git rev-list --count "$branch" --not "$default_branch")
          echo "$branch | $commit_count"
      fi
  done
}

catdir() {
  # Check if a directory path is provided as an argument
  if [ -z "$1" ]; then
    echo "Usage: print_directory_contents <directory_path>"
    return 1
  fi

  # Function to print the contents of files with separators
  local directory="$1"

  _print_files() {
    for file in "$1"/*; do
      if [ -d "$file" ]; then
        # Recursively call the function if it's a directory
        _print_files "$file"
      elif [ -f "$file" ]; then
        # Print file path and content
        echo "========== FILE: $file =========="
        cat "$file"
        echo "=================================="
        echo
      fi
    done
  }

  # Start the process
  _print_files "$directory"
}
